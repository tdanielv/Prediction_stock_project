In the previous code, the model is trained using historical stock data, and then it is used to make a prediction for the next day's stock price based on the last day's stock price. The model uses the patterns and trends learned from the historical data to make predictions for future prices. This is known as supervised learning.

It's important to note that the model is not able to predict future prices with 100% accuracy as stock prices are influenced by a variety of factors including economic, political and global events, which can be unpredictable. Additionally, the model can be affected by overfitting and underfitting if it's not trained and tested properly.

Also, the model is only able to predict the next day's stock price, based on the last day's stock price. In order to predict the future price for multiple days, you need to make predictions for each day and use the predicted price as the input for the next prediction.

It's also important to mention that it's always a good idea to test the model's performance on unseen data, also known as validation data, to make sure that the model generalizes well to new data and not overfitting the training data.


В предыдущем коде модель обучается с использованием исторических данных о запасах, а затем используется для прогнозирования цены акций на следующий день на основе цены акций за последний день. Модель использует закономерности и тенденции, извлеченные из исторических данных, для прогнозирования будущих цен. Это известно как контролируемое обучение.

Важно отметить, что модель не способна предсказать будущие цены со 100% точностью, поскольку на цены акций влияют различные факторы, включая экономические, политические и глобальные события, которые могут быть непредсказуемыми. Кроме того, на модель может повлиять переоснащение и недостаточная комплектация, если она не обучена и не протестирована должным образом.

Кроме того, модель способна предсказать цену акций только на следующий день, основываясь на цене акций за последний день. Чтобы спрогнозировать будущую цену на несколько дней, вам необходимо делать прогнозы на каждый день и использовать прогнозируемую цену в качестве входных данных для следующего прогноза.

Также важно упомянуть, что всегда полезно протестировать производительность модели на невидимых данных, также известных как данные проверки, чтобы убедиться, что модель хорошо обобщается на новые данные и не перегружает обучающие данные.



Определения, чтобы не потерять:
API - Application Programming Interface (программный интерфейс приложения) - набор правил взаимодействия с каким-либо сервисом с помощью программных запросов. По сути, это описание как можно обратиться к сервису и какие ответы от него получить, без необходимости разбираться как именно сервис работает "под капотом". В контексте написания телеграм-ботов, имеется в виду Telegram Bot API.

Callback - "обратный вызов" - это функция, которая передается в диспетчер, чтобы быть вызванной при наступлении соответствующих условий. То есть, если апдейт прошел соответствующий фильтр - вызывается callback-функция.

Callback Query - апдейт, который приходит боту, если пользователь нажал на инлайн-кнопку.

Deep-link - "глубокая ссылка" - ссылка вида https://t.me/my_bot?start=some_data, по которой пользователь может перейти в чат с телеграм-ботом. В чате, после перехода по ссылке, появится кнопка START, при нажатии на которую бот получит не только команду /start, но и данные some_data. Бывает полезно, если нужно отследить откуда пришел пользователь или для реферальной программы.

Deploy - "развертывание" - запуск бота на удаленном сервере для бесперебойной работы.

Dispatcher - "диспетчер" - специальный объект aiogram, который занимается получением апдейтов от серверов Telegram, распаковывает их и передает в соответствующие хэндлеры (обработчики).

Executor - специальный класс в aiogram, который содержит в себе методы для запуска бота, либо в режиме long polling, либо в режиме webhook.

Filter - "фильтр" - шаблон, которому должен соответствовать апдейт или его часть, чтобы сработал отвечающий за него хэндлер. То есть когда боту приходит апдейт, диспетчер пытается последовательно пропустить его через фильтры и, как только объект проходит первый фильтр - срабатывает хэндлер, настроенный на обработку апдейта, прошедшего этот фильтр.

FSM (Finite State Machine) - "машина состояний" - конечный автомат, который позволяет хранить состояние пользователя бота, чтобы в зависимости от этого состояния и действий пользователя, переводить пользователя в другие состояния.

Handler - "обработчик" - функция, которая обрабатывает апдейт. В идеале, одна функция на каждый тип апдейтов с одинаковым или близким содержимым. Делать большую функцию, где проверять свойства апдейтов с помощью if...else - это, чаще всего, плохая практика.

Inline-кнопка - "инлайн-кнопка" - кнопка, которая прикрепляется к отправляемому сообщению и может быть отправлена только как часть этого сообщения, в отличие от "обычных" кнопок, которые заменяют стандартную пользовательскую клавиатуру и не прикреплены к какому-либо сообщению бота.

Inline-режим (inline-mode) - "инлайн-режим" - режим взаимодействия пользователя с ботом через поле ввода сообщения, без прямой отправки сообщения боту. Пользователь вводит в любом чате "@имя_бота," а затем запрос. Бот сразу получает апдейты, не дожидаясь пока пользователь полностью введет сообщение.

Long polling - "долгий опрос" - способ взаимодействия бота с сервером Telegram, путем постоянного опроса сервера на предмет наличия апдейтов, но с таймаутом до разрыва соединения. То есть, бот ждет ответа от сервера какое-то время, не разрывая соединения. Если за это время апдейтов нет - сервер сообщает, что апдейтов нет и разрывает соединение. Боту нужно снова посылать запрос. А если апдейты есть, то сервер их боту отправляет сразу, не дожидаясь окончания соединения.

Middleware - "промежуточное программное обеспечение" - специальная программа, которая является прослойкой между другими программами, передавая информацию от одной к другой. В контексте aiogram - это код, который предназначен что-то сделать с апдейтами до того, как они попадут в хэндлеры.

Polling - "опрос" - способ получения апдейтов ботом от серверов Telegram, путем постоянного опроса этих серверов на наличие обновлений. В отличие от лонг поллинга, сервер отвечает сразу, независимо от того, есть апдейты или нет. Если они есть - сервер пересылает их боту, а если нет - отвечает, что апдейтов нет.

Throttling - "удушение" - ограничение количества запросов пользователям. Если от пользователя приходит слишком много бессмысленных апдейтов, которые нагружают систему, имеет смысл не передавать их обработчикам, а просто отсекать.

Token - "токен" - специальный ключ-идентификатор бота, по которому сервера Telegram идентифицируют бота. Имея этот ключ, можно управлять ботом, даже не являясь его владельцем, поэтому токен нужно хранить в защищенном месте и никому, без особой необходимости, не передавать. Владелец бота (именно как специального аккаунта в Telegram) может в любой момент перевыпустить токен.

Update - "апдейт" - сообщение от сервера Telegram, которое получает бот. Но не только текстовое сообщение, которое пользователь отправил в чат, а вообще любое событие, поддерживаемое Telegram Bot API. Полный список возможных апдейтов можно посмотреть в документации.

Username - в рамках Telegram - это уникальное имя бота или пользователя, с помощью которого можно получить доступ к чату с ним (например, @my_bot, @kmsint внутри приложения Telegram и https://t.me/my_bot, https://t.me/kmsint из внешних источников).

Webhook - способ доставки апдейтов боту, при котором не бот постоянно опрашивает серверы Telegram на наличие новых сообщений (апдейтов), а сервер Telegram пересылает все новые апдейты на специальный URL-адрес, когда эти апдейты есть.
